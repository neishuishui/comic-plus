<template>
  <div class="cu-scroll-bar" :class="display" :style="{ width, height }">
    <div class="cu-scroll-bar__container" ref="bar" @scroll="onScroll" v-resize="onResize">
      <div v-resize="onResize">
        <slot></slot>
      </div>
    </div>
    <div class="cu-scroll-bar__thumb thumby" :style="thumbyStyle" @mousedown="mousedowny" v-if="showThumby"></div>
    <div class="cu-scroll-bar__thumb thumbx" :style="thumbxStyle" @mousedown="mousedownx" v-if="showThumbx"></div>
  </div>
</template>

<script lang="ts" setup>
import { ref, computed, nextTick, onMounted, watch } from 'vue';
import '../style/css';
import { useResize } from '../../utils/directive';
import { debounce } from '../../utils/tools';
import { scrollBarProps, scrollBarEmits } from './main.props';
defineOptions({
  name: 'CuScrollBar'
});

const props = defineProps(scrollBarProps);
const emit = defineEmits(scrollBarEmits);

const bar = ref();
const barTop = ref(0);
const barLeft = ref(0);
const barHeight = ref(0);
const barWidth = ref(0);
const minBarSize = 16;

const vResize = useResize();
const onResize = debounce(resateScrollBar, 300);

const showThumby = ref(false);
const showThumbx = ref(false);

watch(
  () => props.display,
  () => {
    computedShowThumb();
  }
);

function computedShowThumb() {
  showThumby.value = props.display === 'none' ? false : bar.value?.offsetHeight < bar.value?.scrollHeight;
  showThumbx.value = props.display === 'none' ? false : bar.value?.offsetWidth < bar.value?.scrollWidth;
}

const thumbyStyle = computed(() => {
  return {
    '--h': Math.max(minBarSize, barHeight.value) + 'px',
    '--t': barTop.value + 'px'
  };
});

const thumbxStyle = computed(() => {
  return {
    '--w': Math.max(minBarSize, barWidth.value) + 'px',
    '--l': barLeft.value + 'px'
  };
});

function onScroll(e: Event) {
  const eTarget = <HTMLElement>e.target;
  barTop.value = (eTarget.scrollTop / eTarget.scrollHeight) * eTarget.offsetHeight;
  barLeft.value = (eTarget.scrollLeft / eTarget.scrollWidth) * eTarget.offsetWidth;

  if (barHeight.value < minBarSize) {
    barTop.value = barTop.value - ((minBarSize - barHeight.value) / eTarget.offsetHeight) * barTop.value;
  }
  if (barWidth.value < minBarSize) {
    barLeft.value = barLeft.value - ((minBarSize - barWidth.value) / eTarget.offsetWidth) * barLeft.value;
  }
  emit('scroll', e);
}

function mousedowny(e) {
  setTop(e.offsetY);
  document.addEventListener('mousemove', movey);
  document.addEventListener('mouseup', up);
}

function mousedownx(e) {
  setLeft(e.offsetX);
  document.addEventListener('mousemove', movex);
  document.addEventListener('mouseup', up);
}
function movey(e) {
  let offsetTop = bar.value.getBoundingClientRect().top;
  setTop(e.clientY - offsetTop);
}

function movex(e) {
  let offsetLeft = bar.value.getBoundingClientRect().left;
  setLeft(e.clientX - offsetLeft);
}

function setTop(offsetY: number) {
  let top = (offsetY / bar.value?.offsetHeight) * bar.value?.scrollHeight;
  top -= (barHeight.value / 2 / bar.value?.offsetHeight) * bar.value?.scrollHeight;
  bar.value.scrollTo({
    top: top
  });
}

function setLeft(offsetX: number) {
  let left = (offsetX / bar.value?.offsetWidth) * bar.value?.scrollWidth;
  left -= (barWidth.value / 2 / bar.value?.offsetWidth) * bar.value?.scrollWidth;
  bar.value.scrollTo({
    left: left
  });
}

function up(e) {
  document.removeEventListener('mousemove', movex);
  document.removeEventListener('mousemove', movey);
  document.removeEventListener('mouseup', up);
}

async function resateScrollBar() {
  await nextTick();
  barHeight.value = (bar.value?.offsetHeight / bar.value?.scrollHeight) * bar.value?.offsetHeight;
  barWidth.value = (bar.value?.offsetWidth / bar.value?.scrollWidth) * bar.value?.offsetWidth;
  barTop.value = (bar.value.scrollTop / bar.value.scrollHeight) * bar.value.offsetHeight;
  barLeft.value = (bar.value.scrollLeft / bar.value.scrollWidth) * bar.value.offsetWidth;

  if (barHeight.value < minBarSize) {
    barTop.value = barTop.value - ((minBarSize - barHeight.value) / bar.value.offsetHeight) * barTop.value;
  }
  if (barWidth.value < minBarSize) {
    barLeft.value = barLeft.value - ((minBarSize - barWidth.value) / bar.value.offsetWidth) * barLeft.value;
  }
  computedShowThumb();
}

function setBarTop(top) {
  bar.value.scrollTo({
    top,
    behavior: 'smooth'
  });
}

function setBarLeft(left) {
  bar.value.scrollTo({
    left,
    behavior: 'smooth'
  });
}

defineExpose({ setBarTop, setBarLeft, showThumby, showThumbx });

onMounted(() => {
  resateScrollBar();
});
</script>
