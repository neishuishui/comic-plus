<template>
  <div class="cu-form-item" :class="{ required: isRequired, 'is-error': errorMsg }">
    <span class="label" :style="labelStyle">
      <slot name="label">{{ label }}</slot>
    </span>
    <span class="cu-form-item__content">
      <slot></slot>
      <transition name="cu-error">
        <span class="cu-form__error" v-if="errorMsg">{{ errorMsg }}</span>
      </transition>
    </span>
  </div>
</template>

<script setup lang="ts">
import { inject, computed, onMounted, ref, provide, getCurrentInstance, onUnmounted } from 'vue';
import '../style/css';
import { isNumber } from '../../utils/tools.js';
import Schema from 'async-validator';
import { formItemProps } from './item.props';
defineOptions({
  name: 'CuFormItem'
});
const props = defineProps(formItemProps);
const instance = getCurrentInstance()!;

const parentLabelWidth = inject<object | null>('form:labelWidth', null);
const parentLabelPosition = inject<object | null>('form:labelPosition', null);
const rules = inject<object | object[]>('form:rules');
const itemValidatePush = inject<Function>('form:validatepush');
const itemValidateDelete = inject<Function>('form:validatedelete');

const model = inject<object>('form:model');
const errorMsg = ref<string>('');

const descriptor = computed(() => {
  let arr: any[] = [];
  if (props.rules) {
    arr = arr.concat(props.rules);
  }
  if (props.prop && rules?.[props.prop]) {
    arr = arr.concat(rules?.[props.prop]);
  }
  return arr || [];
});

const isRequired = computed(() => {
  let reqArr = descriptor.value
    .map((v) => {
      return v?.required;
    })
    .filter(Boolean);
  return props.required || reqArr.length > 0;
});

const labelStyle = computed(() => {
  if (parentLabelPosition && parentLabelPosition.value != 'top') {
    return {
      width: props.labelWidth ?? parentLabelWidth?.value ?? undefined
    };
  }
  return undefined;
});

const trigger = computed(() => {
  if (!props.prop) return [];
  let arr = descriptor.value.filter((v) => v.hasOwnProperty('trigger')).map((v) => v.trigger);
  return arr || [];
});

function isTypeof(val: any, type: string | null = null) {
  if (typeof val === 'object') {
    return Array.isArray(val) ? 'array' : 'object';
  }
  return typeof val;
}

function validate() {
  if (props.prop) {
    let t = model?.[props.prop];
    let k = props.prop;
    if (isNumber(props.propIndex)) {
      t = t[props.propIndex];
      k = k + '.' + props.propIndex;
    }
    let fied = Object.assign({}, { type: isTypeof(t) }, { [k]: descriptor.value });
    const validator = new Schema(fied);
    return validator.validate({ [k]: t }, { firstFields: true }, (err) => {
      errorMsg.value = '';
      if (err) {
        errorMsg.value = err[0].message || '';
        return;
      }
    });
  } else {
    return true;
  }
}

function clearValidate() {
  errorMsg.value = '';
}

provide('form-item:validate', { trigger: trigger.value, fn: validate });

onMounted(() => {
  if (props.prop && itemValidatePush) {
    let k = props.prop;
    if (isNumber(props.propIndex)) {
      k = k + '.' + props.propIndex;
    }
    itemValidatePush({
      uid: instance.uid,
      prop: k,
      validate,
      clearValidate
    });
  }
});
onUnmounted(() => {
  itemValidateDelete(instance.uid);
});
</script>
