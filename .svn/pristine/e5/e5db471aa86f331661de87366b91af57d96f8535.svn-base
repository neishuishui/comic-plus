<template>
  <div
    class="cu-date-picker"
    :style="{ width }"
    :class="[{ checked: show }, { 'is-disabled': disabled }, { range }, currentSize]"
    v-click-outside:datePicker="onClickOutside"
  >
    <div
      class="cu-date-picker__inner"
      :style="clearable ? 'padding-right:18px;' : undefined"
      @click="handleClick"
      @mouseover="mouseover"
      @mouseleave="mouseleave"
    >
      <i :class="icon"></i>
      <input
        type="text"
        readonly
        :value="range ? formatDate(new Date(modelValue[0]), format) : formatDate(new Date(modelValue), format)"
        :placeholder="range ? startPlaceholder : placeholder"
        :disabled="disabled"
      />
      <span v-if="range">{{ rangeSeparator }}</span>
      <input
        v-if="range"
        type="text"
        readonly
        :value="formatDate(new Date(modelValue[1]), format)"
        :placeholder="endPlaceholder"
        :disabled="disabled"
      />
      <i class="cu-icon-close-one clearable" v-show="showClose" v-if="clearable" @click.stop="clear"></i>
    </div>
    <cu-popper :show="show">
      <div class="cu-date-picker__popper" :class="{ range }" outside="datePicker">
        <cu-date-select
          @pick="updateValue"
          :shortcuts="shortcuts"
          :value="modelValue"
          @cancel="show = false"
          :range="range"
        ></cu-date-select>
      </div>
    </cu-popper>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, inject } from 'vue';
import type { ComputedRef } from 'vue';
import '../style/date-picker.css';
import '../../form-common.css';
import { CuPopper } from '../../popper';
import CuDateSelect from './date-select.vue';
import { useClickOutside, formatDate, useConfig } from '../../../utils';
import { datePickerProps, datePickerEmits } from './main.props';
defineOptions({
  name: 'CuDatePicker'
});
const props = defineProps(datePickerProps);
const emit = defineEmits(datePickerEmits);

const { SIZE } = useConfig();
const formSize = inject<ComputedRef<string> | null>('form:size', null);

const currentSize = computed(() => {
  return props.size ?? formSize?.value ?? SIZE?.value;
});

const vClickOutside = useClickOutside();

const showClose = ref(false);
const show = ref(false);

const isModelValue = computed(() => {
  if (props.range) {
    return props.modelValue.length > 0;
  }
  return !!props.modelValue;
});

function clear() {
  emit('update:modelValue', props.range ? [] : '');
  emit('clear');
  showClose.value = false;
  show.value = false;
}
function onClickOutside() {
  show.value && (show.value = false);
}
function handleClick() {
  if (props.disabled) return;
  show.value = !show.value;
}
function mouseover() {
  if (props.disabled) return;
  isModelValue.value && (showClose.value = true);
}

function mouseleave() {
  if (props.disabled) return;
  isModelValue.value && (showClose.value = false);
}

function updateValue(value: number | number[]) {
  let val: string | number | Date | string[] | number[] | Date[];
  if (Array.isArray(value)) {
    if (value[0] > value[1]) {
      value.reverse();
    }
  }
  switch (props.valueFormat) {
    case 'date':
      if (props.range) {
        val = [new Date(value[0]), new Date(value[1])];
      } else {
        val = new Date(value);
      }
      break;
    case 'string':
      if (props.range) {
        val = [formatDate(value[0], props.format), formatDate(value[1], props.format)];
      } else {
        val = formatDate(value, props.format);
      }
      break;
    case 'number':
      val = value;
      break;
    default:
      val = value;
      break;
  }
  emit('update:modelValue', val);
  show.value = false;
}
</script>
