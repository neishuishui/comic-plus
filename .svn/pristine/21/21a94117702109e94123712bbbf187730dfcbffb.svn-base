<template>
  <Teleport :to="toElement" :disabled="disabledTeleport">
    <transition name="dropdown">
      <div :style="style" class="cu-dropdown" :class="innerClass" v-if="show">
        <div class="cu-dropdown__inner" ref="dropdownInner" v-resize="onResize" :class="innerClass">
          <slot></slot>
        </div>
      </div>
    </transition>
  </Teleport>
</template>

<script setup lang="ts">
import { inject, watch, ref, nextTick, onMounted } from 'vue';
import '../style/css';
import { getMaxZIndex } from '../../utils/tools.js';
import { useResize } from '../../utils//directive.js';
import { useScrollSever } from '../../utils/scroll-sever.js';
import { dropdownProps } from './main.props';

defineOptions({
  name: 'CuDropdown'
});
const props = defineProps(dropdownProps);

const style = ref<object>({});
const innerClass = ref('top');
const dropdownInner = ref();

const vResize = useResize();

const $parent = inject<HTMLElement | null>('parent:dom', null);

watch(
  () => props.show,
  (val: boolean, old: boolean) => {
    if (!val || val === old) return;
    nextTick(() => {
      setDropdownStyle();
    });
  }
);

function setDropdownStyle() {
  if (!$parent) return;
  let parentRect = $parent.value.getBoundingClientRect();
  if (parentRect.left + dropdownInner.value.offsetWidth > window.innerWidth) {
    let difference = parentRect.left + dropdownInner.value.offsetWidth - window.innerWidth;
    style.value.left = parentRect.left - difference + 'px';
    style.value['--left'] = difference + 20 + 'px';
  } else {
    style.value.left = parentRect.left + 'px';
    style.value['--left'] = '20px';
  }

  if (parentRect.top + parentRect.height + dropdownInner.value.offsetHeight > window.innerHeight) {
    style.value.bottom = window.innerHeight + parentRect.height - parentRect.bottom + 'px';
    style.value.top = 'auto';
    innerClass.value = 'bottom';
  } else {
    style.value.top = parentRect.top + parentRect.height + 'px';
    style.value.bottom = 'auto';
    innerClass.value = 'top';
  }
  style.value.minWidth =
    props.minWidth && parentRect.width > props.minWidth ? props.minWidth + 'px' : parentRect.width + 'px';
  style.value.zIndex = getMaxZIndex();
}

function onResize(e: object) {
  if (!$parent) return;
  let parentRect = $parent.value.getBoundingClientRect();
  if (parentRect.left + e.width > window.innerWidth) {
    let difference = parentRect.left + e.width - window.innerWidth;
    style.value.left = parentRect.left - difference + 'px';
    style.value['--left'] = difference + 20 + 'px';
  } else {
    style.value.left = parentRect.left + 'px';
    style.value['--left'] = '20px';
  }
}
function setPostion() {
  if (!$parent || !props.show) return;
  let parentRect = $parent.value.getBoundingClientRect();
  if (parentRect.top + parentRect.height + dropdownInner.value.offsetHeight > window.innerHeight) {
    style.value.top = 'auto';
    style.value.bottom = window.innerHeight + parentRect.height - parentRect.bottom + 'px';
    innerClass.value = 'bottom';
  } else {
    style.value.top = parentRect.top + parentRect.height + 'px';
    style.value.bottom = 'auto';
    innerClass.value = 'top';
  }
}

onMounted(() => {
  if ($parent || !props.show) {
    useScrollSever($parent.value, () => {
      setPostion();
    });
  }
});
</script>
