<template>
  <div class="cu-scrollbar" :class="display" :style="{ height }">
    <div class="cu-scrollbar__container" :style="{ 'max-height': maxHeight }" ref="barContainerRef" @scroll="onScroll">
      <div ref="containerDivRef">
        <slot></slot>
      </div>
    </div>
    <div class="cu-scrollbar__thumb thumby" :style="thumbyStyle" @mousedown="mousedowny" v-if="hasThumby"></div>
    <div class="cu-scrollbar__thumb thumbx" :style="thumbxStyle" @mousedown="mousedownx" v-if="hasThumbx"></div>
  </div>
</template>

<script lang="ts" setup>
import { ref, computed, nextTick, onMounted, watch } from 'vue';
import { useEventListener, useElementSize } from '@vueuse/core';
import '../style/scrollbar.css';
import { scrollbarProps, scrollbarEmits } from './main.props';
defineOptions({
  name: 'CuScrollbar'
});

const props = defineProps(scrollbarProps);
const emit = defineEmits(scrollbarEmits);

const barContainerRef = ref(null);
const containerDivRef = ref(null);

const barTop = ref(0);
const barLeft = ref(0);
const barHeight = ref(0);
const barWidth = ref(0);
const minBarSize = 16;

const hasThumby = ref(false);
const hasThumbx = ref(false);

var clearMoveY: Function | null, clearMoveX: Function | null, clearUp: Function | null;

watch(
  () => props.display,
  () => {
    computedShowThumb();
  }
);
const { width: cWidth, height: cHeight } = useElementSize(barContainerRef);
const { width: dWidth, height: dHeight } = useElementSize(containerDivRef);

watch([cWidth, cHeight, dWidth, dHeight], () => {
  resateScrollBar();
});

function computedShowThumb() {
  hasThumby.value =
    props.display === 'never' ? false : barContainerRef.value?.offsetHeight < barContainerRef.value?.scrollHeight;
  hasThumbx.value =
    props.display === 'never' ? false : barContainerRef.value?.offsetWidth < barContainerRef.value?.scrollWidth;
}

const thumbyStyle = computed(() => {
  return {
    '--cu-scrollbar-barheight': Math.max(minBarSize, barHeight.value) + 'px',
    '--cu-scrollbar-bartop': barTop.value + 'px'
  };
});

const thumbxStyle = computed(() => {
  return {
    '--cu-scrollbar-barwidth': Math.max(minBarSize, barWidth.value) + 'px',
    '--cu-scrollbar-barleft': barLeft.value + 'px'
  };
});

function onScroll(e: Event) {
  const eTarget = <HTMLElement>e.target;
  barTop.value = (eTarget.scrollTop / eTarget.scrollHeight) * eTarget.offsetHeight;
  barLeft.value = (eTarget.scrollLeft / eTarget.scrollWidth) * eTarget.offsetWidth;

  if (barHeight.value < minBarSize) {
    barTop.value = barTop.value - ((minBarSize - barHeight.value) / eTarget.offsetHeight) * barTop.value;
  }
  if (barWidth.value < minBarSize) {
    barLeft.value = barLeft.value - ((minBarSize - barWidth.value) / eTarget.offsetWidth) * barLeft.value;
  }

  emit('scroll', e);
}

function mousedowny(e) {
  e.preventDefault();
  setTop(e.offsetY);
  clearMoveY = useEventListener(document, 'mousemove', movey);
  clearUp = useEventListener(document, 'mouseup', up);
}

function mousedownx(e) {
  e.preventDefault();
  setLeft(e.offsetX);
  clearMoveX = useEventListener(document, 'mousemove', movex);
  clearUp = useEventListener(document, 'mouseup', up);
}
function movey(e) {
  let offsetTop = barContainerRef.value.getBoundingClientRect().top;
  setTop(e.clientY - offsetTop);
}

function movex(e) {
  let offsetLeft = barContainerRef.value.getBoundingClientRect().left;
  setLeft(e.clientX - offsetLeft);
}

function setTop(offsetY: number) {
  let top = (offsetY / barContainerRef.value?.offsetHeight) * barContainerRef.value?.scrollHeight;
  top -= (barHeight.value / 2 / barContainerRef.value?.offsetHeight) * barContainerRef.value?.scrollHeight;
  barContainerRef.value.scrollTo({
    top: top
  });
}

function setLeft(offsetX: number) {
  let left = (offsetX / barContainerRef.value?.offsetWidth) * barContainerRef.value?.scrollWidth;
  left -= (barWidth.value / 2 / barContainerRef.value?.offsetWidth) * barContainerRef.value?.scrollWidth;
  barContainerRef.value.scrollTo({
    left: left
  });
}

function up() {
  clearMoveX?.();
  clearMoveY?.();
  clearUp?.();
}

async function resateScrollBar() {
  await nextTick();
  const dom = barContainerRef.value;
  if (!dom) return;
  barHeight.value = (dom.offsetHeight / dom.scrollHeight) * dom.offsetHeight;
  barWidth.value = (dom.offsetWidth / dom.scrollWidth) * dom.offsetWidth;
  barTop.value = (dom.scrollTop / dom.scrollHeight) * dom.offsetHeight;
  barLeft.value = (dom.scrollLeft / dom.scrollWidth) * dom.offsetWidth;

  if (barHeight.value < minBarSize) {
    barTop.value = barTop.value - ((minBarSize - barHeight.value) / dom.offsetHeight) * barTop.value;
  }
  if (barWidth.value < minBarSize) {
    barLeft.value = barLeft.value - ((minBarSize - barWidth.value) / dom.offsetWidth) * barLeft.value;
  }
  computedShowThumb();
}

function setBarTop(top: number) {
  barContainerRef.value.scrollTo({
    top,
    behavior: 'smooth'
  });
}

function setBarLeft(left: number) {
  barContainerRef.value.scrollTo({
    left,
    behavior: 'smooth'
  });
}

function getScrollEvent() {
  return barContainerRef.value;
}

defineExpose({ setBarTop, setBarLeft, getScrollEvent, hasThumby, hasThumbx });

onMounted(() => {
  resateScrollBar();
});
</script>
