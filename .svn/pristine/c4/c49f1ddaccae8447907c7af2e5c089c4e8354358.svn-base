<template>
  <div
    class="cu-cascader"
    ref="cascader"
    :class="[{ checked: show }, { 'is-disabled': disabled }, size ?? formSize ?? SIZE]"
    v-click-outside:cascaderDropdown="onClickOutside"
  >
    <div class="cu-cascader__inner" @click="handleClick" @mouseover="mouseover" @mouseleave="mouseleave">
      <input type="text" readonly :value="useInputValue" :placeholder="placeholder" :disabled="disabled" />
      <i class="cu-icon-bottom" v-show="!showClose || !clearable"></i>
      <i class="cu-icon-close-c" v-show="showClose" v-if="clearable" @click.stop="clear"></i>
    </div>
    <dropdown :show="show" :duration="200" :min-width="180">
      <div class="cu-cascader__dropdown" :class="size ?? formSize ?? SIZE" outside="cascaderDropdown">
        <div class="cu-cascader-pane">
          <div
            class="cu-cascader-pane__item"
            v-for="(item, index) in options"
            :key="item[optionProps.value]"
            :class="[
              { active: recodeValues.map((v) => v[optionProps.value]).includes(item[optionProps.value]) },
              { disabled: item.disabled }
            ]"
            @click="itemHandleClick(null, item)"
          >
            <span>{{ item[optionProps.label] }}</span>
            <i class="cu-icon-right" v-if="item[optionProps.children]"></i>
          </div>
        </div>
        <template v-for="(item, index) in recodeValues">
          <div class="cu-cascader-pane" :key="item[optionProps.value]" v-if="item[optionProps.children]">
            <div
              class="cu-cascader-pane__item"
              v-for="child in item[optionProps.children]"
              :class="[
                { active: recodeValues.map((v) => v[optionProps.value]).includes(child[optionProps.value]) },
                { disabled: child.disabled }
              ]"
              @click="itemHandleClick(item[optionProps.value], child)"
            >
              <span>{{ child[optionProps.label] }}</span>
              <i class="cu-icon-right" v-if="child[optionProps.children]"></i>
            </div>
          </div>
        </template>
      </div>
    </dropdown>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, provide, watch, inject } from 'vue';
import '../style/css';
import dropdown from '../../dropdown/src/main.vue';
import { deleteAfterIndex } from '../../utils/tools.js';
import { useClickOutside } from '../../utils/directive.js';
import useItemValidate from '../../utils/mixin/validate.js';
import { useConfig } from '../../utils/config.js';
defineOptions({
  name: 'CuCascader'
});
const props = defineProps({
  modelValue: {
    type: Array,
    required: true
  },
  options: {
    type: Array,
    required: true
  },
  size: String,
  disabled: Boolean,
  width: String,
  clearable: Boolean,
  arbitrarily: Boolean,
  placeholder: String,
  prop: {
    type: Object,
    default: () => {
      return {
        children: 'children',
        label: 'label',
        value: 'value',
        separator: '/'
      };
    }
  }
});
const emit = defineEmits(['update:modelValue', 'change', 'clear']);

const { itemValidate } = useItemValidate();
const { SIZE } = useConfig();
const formSize = inject<string | null>('form:size', null);

const show = ref(false);
const showClose = ref(false);
const recodeValues = ref<unknown[]>([]);
const inputValue = ref<unknown[]>([]);
const cascader = ref();
const vClickOutside = useClickOutside();

watch(
  () => props.modelValue,
  (val: unknown[]) => {
    inputValue.value = [];
    let arr = props.options;
    val.forEach((item) => {
      let current = arr.find((v) => v[optionProps.value.value] === item) || null;
      if (current) {
        inputValue.value.push(current);
        arr = current[optionProps.value.children] || [];
      }
    });
  }
);
watch(show, (val: boolean) => {
  if (val) {
    recodeValues.value = [];
    recodeValues.value = [...inputValue.value];
  }
});

const useInputValue = computed(() => {
  return inputValue.value.map((v) => v[optionProps.value.label]).join(optionProps.value.separator);
});

const optionProps = computed(() => {
  return Object.assign(
    {},
    {
      children: 'children',
      label: 'label',
      value: 'value'
    },
    props.prop
  );
});

function onClickOutside(e: Event) {
  show.value && (show.value = false);
}

function handleClick() {
  show.value = !show.value;
}
function mouseover() {
  if (props.disabled) return;
  props.modelValue.length > 0 && (showClose.value = true);
}

function mouseleave() {
  if (props.disabled) return;
  props.modelValue.length > 0 && (showClose.value = false);
}

function itemHandleClick(parentVal: string | number | null, val: object) {
  if (val.disabled) return;
  if (parentVal != null) {
    let index = recodeValues.value.findIndex((v) => v[optionProps.value.value] === parentVal);
    if (index >= 0) {
      deleteAfterIndex(recodeValues.value, index);
    }
  } else {
    recodeValues.value = [];
  }
  recodeValues.value.push(val);
  if (!val[optionProps.value.children] || props.arbitrarily) {
    let value = recodeValues.value.map((v) => v?.[optionProps.value.value]);
    emit('update:modelValue', value);
    change(value);
    !props.arbitrarily && (show.value = false);
  }
}

function change(val: string[] | any[]) {
  emit('change', val);
  itemValidate('change');
}

function clear() {
  showClose.value && (showClose.value = false);
  show.value && (show.value = false);
  emit('update:modelValue', []);
  change([]);
  emit('clear');
}

provide('parent:dom', cascader);
</script>
