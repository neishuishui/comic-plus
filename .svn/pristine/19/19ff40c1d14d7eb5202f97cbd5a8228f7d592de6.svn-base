<template>
  <div
    class="cu-table"
    ref="tableRef"
    :class="[
      { border: options.border },
      { 'show-left-shadow': tableResize.leftShadow },
      { 'show-right-shadow': tableResize.rightShadow },
      { 'is-selection': options.selection },
      size ?? SIZE
    ]">
    <div class="cu-table__head" :class="headerClassName" ref="tableHeadRef">
      <table :style="{ width: tableResize.width - tableResize.scrollWidth + 'px' }">
        <colgroup>
          <col v-if="options.selection" style="width: 40px; min-width: 40px" />
          <col
            v-for="(th, index) in columns"
            :key="index"
            :style="{
              width: (th.width || tableResize.flexWidth) + 'px',
              minWidth: (th.width || tableResize.flexWidth) + 'px'
            }" />
          <col :style="{ width: tableResize.scrollWidth + 'px' }" />
        </colgroup>
        <thead>
          <tr class="cu-table__row" :style="options.headStyle">
            <th
              class="cu-table__th checkbox fixed-left"
              :class="{ 'fixed-shadow-left': getStickyIndex.left == -1 }"
              width="40"
              v-if="options.selection">
              <cu-checkbox :modelValue="isCheckAll" @change="_changeCheckAll" :ispart="ispart"></cu-checkbox>
            </th>
            <th
              class="cu-table__th"
              v-for="(th, index) in columns"
              :key="index"
              :class="[
                th.fixed ? 'fixed-' + th.fixed : undefined,
                { 'fixed-shadow-left': getStickyIndex.left == index },
                { 'fixed-shadow-right': getStickyIndex.right == index }
              ]"
              :style="styles(th, index, tableResize.scrollWidth)">
              <span>
                <slot :name="'th-' + th.prop">{{ th.label }}</slot>
              </span>
            </th>
            <th class="cu-table__th fixed-right" v-if="tableResize.scrollWidth"></th>
          </tr>
        </thead>
      </table>
    </div>

    <div
      class="cu-table__body"
      :class="[
        {
          stripe: options.stripe,
          'table-expand': isTableTree || expand,
          'scrolly-body': tableResize.scrollWidth > 0
        },
        bodyClassName
      ]"
      ref="tableBodyRef"
      :style="{
        width: tableResize.width + 'px',
        'max-height': height,
        '--stripe-odd': stripeStyle[0] ?? undefined,
        '--stripe-even': stripeStyle[1] ?? undefined,
        ...options.bodyStyle
      }"
      @scroll="scroll">
      <table :style="{ width: tableResize.width - tableResize.scrollWidth + 'px' }">
        <colgroup>
          <col v-if="options.selection" style="width: 40px; min-width: 40px" />
          <col
            v-for="(td, index) in columns"
            :key="index"
            :style="{
              width: (td.width || tableResize.flexWidth) + 'px',
              minWidth: (td.width || tableResize.flexWidth) + 'px'
            }" />
        </colgroup>
        <tbody>
          <div class="cu-table__empty" v-if="data.length === 0">暂无数据</div>
          <template v-for="(item, index) in data" :key="index">
            <cu-table-tr
              v-bind="props"
              :column-data="item"
              :checkList="checkList"
              :index="index"
              :tree-props="provideTreeProps"
              @change-selection="_changeSelection"
              @add-option="_addOption">
              <template v-for="td in columns" #[td.prop]="{ row }">
                <slot :name="td.prop" :row="row" :index="index"> </slot>
              </template>
              <template #expand="{ row }" v-if="expand && $slots.expand">
                <slot name="expand" :row="row" :index="index"> </slot>
              </template>
            </cu-table-tr>
          </template>
        </tbody>
      </table>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, computed, watch } from 'vue';
import { useElementSize } from '@vueuse/core';
import '../style/table.css';
import CuTableTr from './components/table-tr.vue';
import { flattenArray, useConfig } from '../../../utils';
import { CuCheckbox } from '../../checkbox';
import { tableProps, tableEmits } from './main.props';
import type { TreeProps } from './main.props';
defineOptions({
  name: 'CuTable'
});

interface Tableresize {
  width: number;
  height: number;
  flexWidth: number;
  leftShadow: boolean;
  rightShadow: boolean;
  scrollWidth: number;
}

const props = defineProps(tableProps);
const emit = defineEmits(tableEmits);

const { SIZE } = useConfig();

const tableRef = ref(null);
const tableHeadRef = ref(null);
const tableBodyRef = ref(null);

const { width: tWidth, height: tHeight } = useElementSize(tableRef);

watch([tWidth, tHeight], (val) => {
  getResize({
    width: val[0],
    height: val[1]
  });
});

const MIN_SIZE = 120;

const tableResize = reactive({
  width: 0,
  height: 0,
  flexWidth: 0,
  leftShadow: false,
  rightShadow: false,
  scrollWidth: 0
}) as Tableresize;
const checkList = ref<any[]>([]);

watch(props.data, () => {
  checkList.value.splice(0);
});
watch(checkList.value, (val) => {
  emit('select-change', val);
});

const provideTreeProps = reactive(Object.assign({ children: 'children' }, props.treeProps)) as TreeProps;

const canSelectionDatas = ref<any[]>(flattenArray(props.data, provideTreeProps.children));

function _addOption(arr: any[]) {
  canSelectionDatas.value.push(...arr);
}

const isTableTree = computed(() => {
  return (
    props.data.filter((v) => {
      return !!v[provideTreeProps.children ?? 'children'] || v[provideTreeProps.hasChildren!];
    }).length > 0
  );
});

const stripeStyle = computed(() => {
  if (!props.options?.stripe) return [];
  let s: any = props.options.bodyStyle || null;
  if (props.options.stripeColors) {
    return [props.options.stripeColors[0] ?? '#fff', props.options.stripeColors[1] ?? '#fafafa'];
  } else {
    return ['#fff', s?.backgroundColor ?? '#fafafa'];
  }
});
const columns = computed(() => {
  let column = props.options?.column ?? [];
  column = column.sort((a, b) => {
    if (a.fixed === 'left' && (!b.fixed || b.fixed !== 'left')) {
      return -1;
    } else if (b.fixed === 'left' && (!a.fixed || a.fixed !== 'left')) {
      return 1;
    } else if (a.fixed === 'right' && b.fixed !== 'right') {
      return 1;
    } else if (b.fixed === 'right' && a.fixed !== 'right') {
      return -1;
    } else {
      return 0;
    }
  });
  return column;
});

const ispart = computed(() => {
  if (!props.options?.selection) return false;
  return checkList.value.length > 0 && checkList.value.length < canSelectionDatas.value.length;
});

const isCheckAll = computed(() => {
  if (!props.options?.selection) return false;
  return checkList.value.length === canSelectionDatas.value.length;
});

const getStickyIndex = computed(() => {
  return {
    left: findLastObjectWithProperty(),
    right: columns.value?.findIndex((v) => v.fixed === 'right')
  };
});

// 查找具有指定属性的最后一个对象
function findLastObjectWithProperty() {
  for (let i = columns.value?.length! - 1; i >= 0; i--) {
    let item = columns.value?.[i];
    if (item?.fixed === 'left') {
      return i;
    }
  }
  return -1;
}

function styles(css: any, index: number, offset?: number) {
  let obj: any = {};
  obj.textAlign = css.align;
  if (css.fixed === 'left') {
    obj.left = getStickyLeft(index) + 'px';
  } else if (css.fixed === 'right') {
    obj.right = getStickyRight(index) + (offset ?? 0) + 'px';
  }
  return obj;
}

function getStickyLeft(index: number) {
  let left: number = 0;
  if (index > 0) {
    for (let i = 0; i < index; i++) {
      let item = columns.value?.[i];
      left += item?.fixed === 'left' ? item?.width || MIN_SIZE : 0;
    }
  }
  left += props.options?.selection ? 40 : 0;
  return left;
}
function getStickyRight(index: number) {
  let right: number = 0;
  if (index < columns.value?.length! - 1) {
    for (let i = columns.value?.length! - 1; i > index; i--) {
      let item = columns.value?.[i];
      right += item?.fixed === 'right' ? item?.width || MIN_SIZE : 0;
    }
  }
  return right;
}

function scroll(e) {
  tableResize.leftShadow = e.target.scrollLeft > 0;
  tableResize.rightShadow = e.target.scrollWidth - e.target.scrollLeft - e.target.offsetWidth > 0;

  tableHeadRef.value.scrollTo({
    left: e.target.scrollLeft
  });
}

function getResize(rect) {
  const { width, height } = rect;
  let e = tableBodyRef.value;
  tableResize.leftShadow = e.scrollLeft > 0;
  tableResize.rightShadow = e.scrollWidth - e.scrollLeft - e.offsetWidth != 0;
  tableResize.scrollWidth = e.offsetWidth - e.clientWidth;
  tableResize.width = width;
  tableResize.height = height;
  let length = columns.value?.filter((v) => !v.width).length ?? 0;
  let allWidth = columns.value?.reduce((v, o) => (v += Number(o.width) || 0), 0) ?? 0;
  allWidth += props.options?.selection ? 40 : 0;
  let w = (tableResize.width - tableResize.scrollWidth - allWidth) / length;
  tableResize.flexWidth = w <= MIN_SIZE ? MIN_SIZE : w;
}

function _changeSelection(e: boolean, item: any) {
  if (e) {
    selectRow(item);
  } else {
    checkList.value.splice(
      checkList.value.findIndex((v) => v === item),
      1
    );
  }
}
function _changeCheckAll(e: boolean) {
  clearSelection();
  if (e) {
    deepSelection(props.data);
  }
}

function deepSelection(arr: any[]) {
  arr.forEach((row) => {
    if (row[provideTreeProps.children] && Array.isArray(row[provideTreeProps.children])) {
      deepSelection(row[provideTreeProps.children]);
    }
    checkList.value.push(row);
  });
}

function selectRow(row: any | any[]) {
  if (checkList.value.find((v) => v === row)) return;
  row = [].concat(row);
  checkList.value.push(...row);
}
function clearSelection() {
  checkList.value.splice(0);
}

defineExpose({ selectRow, clearSelection });
</script>
