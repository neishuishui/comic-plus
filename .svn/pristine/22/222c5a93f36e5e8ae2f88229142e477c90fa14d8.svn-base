<template>
  <div class="cu-zone" ref="zoneRef" :class="mode" :style="{ '--line-weight': lineWeight + 'px' }">
    <div class="cu-zone__container cu-zone--start" :style="{ [end]: right }">
      <slot name="start"></slot>
    </div>
    <div class="cu-zone__container cu-zone--end" :style="{ [start]: left }">
      <slot name="end"></slot>
    </div>
    <div class="cu-zone__line" :style="{ [start]: left }" ref="lineRef">
      <slot name="line">
        <span class="default-span"></span>
        <span class="default-span"></span>
        <span class="default-span"></span>
        <span class="default-span"></span>
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import '../style/zone.css';
import { useEventListener } from '@vueuse/core';
import { isNumber } from '../../../utils';
import { zoneProps, zoneEmits } from './main.props';

defineOptions({
  name: 'CuZone'
});

const props = defineProps(zoneProps);
const emit = defineEmits(zoneEmits);
const lineRef = ref(null);
const zoneRef = ref(null);
const isNumberValue = ref(isNumber(props.modelValue));

let clearMove = null;
let clearUp = null;

const left = computed(() => {
  return isNumberValue.value ? Number(props.modelValue) * 100 + '%' : props.modelValue;
});
const right = computed(() => {
  return isNumberValue.value ? (1 - Number(props.modelValue)) * 100 + '%' : `calc(100% - ${props.modelValue})`;
});
const start = computed(() => (props.mode === 'horizontal' ? 'left' : 'top'));
const end = computed(() => (props.mode === 'horizontal' ? 'right' : 'bottom'));

function pxToPercent(val: number): number {
  return val / zoneRef.value?.getBoundingClientRect()[props.mode === 'horizontal' ? 'width' : 'height'];
}
function percentToPx(val: number): number {
  return val * zoneRef.value?.getBoundingClientRect()[props.mode === 'horizontal' ? 'width' : 'height'];
}

const getMax = computed<number>(() => {
  if (isNumberValue.value) {
    return isNumber(props.max) ? 1 - Number(props.max) : 1 - pxToPercent(Number(props.max.replace('px', '')));
  } else {
    return isNumber(props.max) ? percentToPx(Number(props.max)) : Number(props.max.replace('px', ''));
  }
});

const getMin = computed<number>(() => {
  if (isNumberValue.value) {
    return isNumber(props.min) ? Number(props.min) : pxToPercent(Number(props.min.replace('px', '')));
  } else {
    return isNumber(props.min) ? percentToPx(Number(props.min)) : Number(props.min.replace('px', ''));
  }
});

useEventListener(lineRef, 'mousedown', onmousedown);

function onmousedown() {
  emit('drag-start');
  clearMove = useEventListener(document, 'mousemove', onmousemove);
  clearUp = useEventListener(document, 'mouseup', onmouseup);
}

function onmouseup() {
  clearMove?.();
  clearUp?.();
  emit('drag-end');
}

function onmousemove(e) {
  e.preventDefault();
  let val: number | string;
  let zoneRect = zoneRef.value.getBoundingClientRect();
  let offset = 0;

  if (props.mode === 'horizontal') {
    offset = e.clientX - zoneRect.left;
    if (isNumberValue.value) {
      val = offset / zoneRect.width;
      val = Math.min(val, getMax.value);
      val = Math.max(val, getMin.value);
    } else {
      offset = Math.min(offset, zoneRect.width - getMax.value);
      offset = Math.max(offset, getMin.value);
      val = offset + 'px';
    }
  } else {
    let offset = e.clientY - zoneRect.top;
    if (isNumberValue.value) {
      val = offset / zoneRect.height;
      val = Math.min(val, getMax.value);
      val = Math.max(val, getMin.value);
    } else {
      offset = Math.min(offset, zoneRect.height - getMax.value);
      offset = Math.max(offset, getMin.value);
      val = offset + 'px';
    }
  }
  emit('update:modelValue', val);
  emit('drag', e);
}
</script>
