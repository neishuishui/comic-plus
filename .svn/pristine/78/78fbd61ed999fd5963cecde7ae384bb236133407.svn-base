<template>
  <div class="cu-slider" :style="'width:' + width">
    <div
      class="cu-slider__inner"
      :class="{ range }"
      :style="'--innerWidth:' + innerWidth.s + '%;' + '--innerWidth2:' + innerWidth.l + '%;' + '--color:' + inputColor"
    >
      <div class="cu-slider__breaks" v-if="inputStep > 0 && showStep">
        <span v-for="b in parseInt(inputMax / inputStep - 1)" :key="b"></span>
      </div>
      <input
        :disabled="disabled"
        :step="inputStep"
        :max="inputMax"
        :min="min"
        type="range"
        :value="inputValue[0]"
        @change="handleChange(0, $event)"
        @input="handleInput(0, $event)"
      />
      <input
        :disabled="disabled"
        v-if="range"
        :step="inputStep"
        :max="inputMax"
        :min="min"
        type="range"
        :value="inputValue[1]"
        @change="handleChange(1, $event)"
        @input="handleInput(1, $event)"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import '../style/css';
import useItemValidate from '../../utils/mixin/validate.js';
defineOptions({
  name: 'CuSlider'
});
const props = defineProps({
  modelValue: {
    type: [Number, Array],
    required: true,
    default: 0
  },
  type: {
    type: String,
    default: 'primary'
  },
  color: String,
  range: Boolean,
  max: {
    type: Number,
    default: 100,
    validator(value: number) {
      return value >= 1;
    }
  },
  min: {
    type: Number,
    default: 0,
    validator(value: number) {
      return value >= 0;
    }
  },
  step: {
    type: Number,
    default: () => {
      return 0;
    }
  },
  showStep: Boolean,
  width: String,
  disabled: Boolean
});

const emit = defineEmits(['update:modelValue', 'change']);

const { itemValidate } = useItemValidate();

const inputColor = computed(() => {
  if (props.color) return props.color;
  return `var(--${props.type})` || 'var(--primary)';
});
const inputMax = computed(() => {
  return props.max === 1 ? 100 : props.max;
});
const inputStep = computed(() => {
  return props.max === 1 ? parseInt(props.step * 100) : props.step;
});
const inputValue = computed(() => {
  let val = props.modelValue;
  if (Array.isArray(val)) {
    !val[0] && (val[0] = 0);
    !val[1] && (val[1] = 0);
  }
  let value = [].concat(val);
  if (value[1] !== undefined) {
    return [
      props.max === 1 ? parseInt(value[0] * 100) : value[0],
      props.max === 1 ? parseInt(value[1] * 100) : value[1]
    ];
  }
  return [props.max === 1 ? parseInt(value[0] * 100) : value[0]];
});

const innerWidth = computed(() => {
  let s = (inputValue.value[0] - props.min) / (props.max - props.min);
  s = props.max === 1 ? s : s * 100;
  let l;
  if (inputValue.value[1] !== undefined) {
    l = (inputValue.value[1] - props.min) / (props.max - props.min);
    l = props.max === 1 ? l : l * 100;
  }
  if (s > l) {
    return {
      s: l,
      l: s
    };
  }
  return {
    s,
    l
  };
});

function handleInput(index: number, e: Event) {
  if (props.range) {
    let arr = inputValue.value;
    arr[index] = Number(props.max === 1 ? e.target.value / 100 : e.target.value);
    emit('update:modelValue', arr);
    return;
  }
  emit('update:modelValue', Number(props.max === 1 ? e.target.value / 100 : e.target.value));
}

function handleChange(index: number, e: Event) {
  if (props.range) {
    let arr = inputValue.value;
    arr[index] = Number(props.max === 1 ? e.target.value / 100 : e.target.value);
    emit('change', arr);
    if (arr[0] > arr[1]) {
      arr.reverse();
      emit('update:modelValue', arr);
    }
    return;
  }
  emit('change', Number(props.max === 1 ? e.target.value / 100 : e.target.value));
  itemValidate('change');
}
</script>
